#!/usr/bin/perl -s

if($h or $help){
    print "
Recursively find all subdirectories that are Git repositories
and execute the Git command passed in the arguments.
The verbose output from Git status is suppressed unless the -v switch is used.

Usage:
  gitall [-h] [-v] [-l] [-q] [-s[=N]] [-r[=c|=f]] [-remote[=URL]] [COMMANDS]

-h -help      print this help message
-l -list      list all subdirectories that are repositories
-v -verbose   provide verbose information for the status command
-q -quiet     execute the Git command without printing the gitall annotations
-s -sleep     sleep 5 seconds after each Git command to avoid ssh access issues
-s=N -sleep=N sleep N seconds after each Git command (N should be more than 1)
-r -reference print Git references 
-r=c          print Git references as a C header with a print statement
-r=f          print Git references as a Fortran write statement
-remote       switch remote to git@gitlab.umich.edu:swmf_software/
-remote=URL   switch remote to URL
COMMANDS      any Git command (cannot be combined with -r or -remote)

Examples:

Show verbose status of all Git subdirectories:
    gitall -v status

Pull remote version into all Git subdirectories and sleep 5 seconds after each:
    gitall -s pull

Print the references for each Git repository:
    gitall -r

Create a C header file to be compiled into the executable
    gitall -r=c > src/gitinfo.h

Switch to the UM GitLab remote server
    gitall -remote

";
    exit 0;
}

my $Verbose   = ($v or $verbose);
my $Sleep     = ($s or $sleep); $Sleep = 5 if $Sleep == 1;
my $List      = ($l or $list);
my $Quiet     = ($q or $quiet);
my $Reference = ($r or $reference);
my $Remote    = ($remote);

use strict;

# Default remote
$Remote = 'git@gitlab.umich.edu:swmf_software' if $Remote eq "1";

my $gitcmd;                # The variable to receive the git command

$gitcmd = join(' ',@ARGV);
$gitcmd .= "; sleep $Sleep" if $Sleep;

my @RefList; 
my $pwd = `pwd`; chop($pwd);

if($gitcmd or $Reference or $List or $Remote){
    &execute_gitall($pwd);
}

@RefList = sort {$b =~ /^Git/ or ($a cmp $b)} @RefList;
if($Reference =~ /c/i){
    print '#include <iostream>
void print_git_info(){
  std::cout 
    << "Main dir=', $pwd,'\n"
    << "', join('\n"'.'
    << "', @RefList),'\n";
}
';
}elsif($Reference =~ /f/i){
    print "
  write(*,'(100(a/))') &
       'Main dir=",$pwd,"', &
       '", join("', &
       '", @RefList),"'
";
}else{
    print join("\n", @RefList),"\n";
}

exit 0;
#==============================================================================

sub execute_gitall(){
   my($dir) = @_;
   opendir(my $DIR,"$dir") or die "gitall can't open directory $dir\n";
   my @gits= grep { /^.git$/ } readdir($DIR);
   closedir($DIR);
   opendir(my $DIR,"$dir") or die "gitall can't open directory $dir\n";
   my @subdirs = grep { /^[^.]/  && -d "$dir/$_"} readdir($DIR);
   closedir($DIR);
   push @subdirs,@gits;

   my $subdir;
   foreach $subdir (@subdirs){
       if ($subdir eq ".git"){
	   if($List){
	       print "$dir\n";
	   }elsif ($Remote){
	       # get current remote repo name
	       my $reponame = `cd $dir; git remote get-url origin`;
	       $reponame =~ s/.*\///;
	       # set new remote
	       `cd $dir; git remote set-url origin $Remote/$reponame`;
	   }elsif ($Reference){
	       my $reponame = "  $dir";
	       $reponame =~ s/$pwd\/// 
		   or $reponame="Git repo=".`git remote get-url origin`;
	       chomp($reponame);

	       $reponame .= " " x (35-length $reponame);
	       
	       # for each repo, get the local reference
	       # this hash references the heads on the user's system
	       my $localref = 
		   `cd $dir; git show master --no-patch --format="%cd %h" --date=short`;
	       $localref =~ s/\n.*//s;
	       
	       # for each repo, get the original reference
	       # this hash references the head in the repo that the user's
	       # repo was cloned from
	       my $originalref = 
		   `cd $dir; git show origin --no-patch --format="%cd %h" --date=short`;
	       $originalref =~ s/\n.*//s;
	       
	       # Use original ref if it is the same as local ref
	       my $ref = $localref eq $originalref ? 
		   "original $originalref" : "local    $localref";
	       $ref .= " " x (30-length $ref);
	       push @RefList, "$reponame $ref";
	   }else{
	       my $result = `cd $dir; git $gitcmd 2>&1`;
	       # remove verbose info
	       if(not $Verbose){
		   $result =~ s/On branch master//;
		   $result =~ s/Your branch is up.to.date with .origin\/master.+//;
		   $result =~ s/nothing to commit, working tree clean//;
		   $result =~ s/^\s*$//g;
	       }
	       if(not $Quiet){
		   print "=========== $dir:\n $result \n" if $result;
	       }else{
		   print "$result" if $result;
	       }
	   }
       }else{
           &execute_gitall("$dir/$subdir");
       }
   }
}






